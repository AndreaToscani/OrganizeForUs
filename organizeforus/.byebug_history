c
auth.info.name
auth.info.keys.name
auth.info.keys
auth.info
auth.keys
user
c
user.email
c
auth
c
auth
c
auth.info.keys
auth
c
auth
auth.info.keys
auth.info
c
auth
auth.info.keys
c
auth.info.keys
auth.info.email
c
auth.info.email
auth
c
Controller
atncz = request.env["omniauth.auth"]
User.from_omniauth(request.env["omniauth.auth"])
auth
auth.extra.raw_info.keys
auth.extra.keys.raw_info
auth.extra.keys.raw_info.keys
auth.extra.keys
auth.credentials.keys
auth.keys
auth.info.email
auth.info.keys
user.email
c
current_user.current_sign_in_ip
current_user
Controller.current_user
c
auth.info
auth.info.profile_url
c
user
c
auth.name
auth.info.keys
auth.extra.raw_info.firstName.keys
auth.extra.raw_info.firstName
auth.extra.raw_info
auth.extra.raw_info.keys
auth.extra.keys
auth.keys.credentials
auth.keys
auth
c
self.email
self.username
@login
c
where(conditions).where(["username = :value OR lower(email) = lower(:value)", { :value => login }]).first
@login
login = conditions.delete(:login)
 conditions = warden_conditions.dup
where(conditions).where(["username = :value OR lower(email) = lower(:value)", { :value => login }]).first
warden_conditions
c
warden_conditions
warden_condition
login
@login
authentication_keys
c
authentication_key
authentication_keys
@login || self.username || self.email
list
vars
session
user
self
self.email
self.username
@login || self.username
@login
quit
dataI
datetimeI
dataI
datetimeI
events
hI
dataI
datetimeI
dateTimeI
quit
@event.user != current_user
!members.include?(current_user) || @event.user != current_user
members.include?( current_user)
members
!members.include?( current_user)
!members.include?(User.find_by(email: current_user.email))
!members.include?(User.find_by(current_user.email))
current_user.email
members.where(email: "org")
members.where(email: org)
members.each do |m| puts m.email end
members.each do |m| puts m end
members
current_user
members
!members.include?(current_user)
quit
members.include?(User.last)
members.include?(User.first)
members.include(User.first)
members 
quit
slot
@slots
quit
@slots
slots
quit
c
dataF
dataI
c
dataF
dataI
quit
@event.position
@position
@event
Event.last
quit
position_params.nil?
position_params.empty?
position_params
quit
@position.longitude
@position.latitude
@position
@event
event
quit
c
quit
position_params
params[:position]
params[:event]
event_params
quit
event_params
quit
event_params
quit
event_params[:position]
event_params[:position
event_params
quit
event_params
quit
event_params
quit
event_params
quit
event[:members].map{|t| {email: t.strip}}
event[:members].map{|t| {email: t.string}}
event[:members].class
event[:members]
quit
event_params[:members].class
event_params[:members]
event_params
quit
params[:event][:members]
params[:event].member
params[:event].members
params[:event]
[:event]
event_params
quit
event_params
quit
event_params
quit
event_params
quit
event_params
quit
event_params
quit
event_params
quit
event_params
quit
event_params
c
email
:email
part
members
:members
c
part.email
:members[]
:members
p
members
part
quit
quit 
compute_total_hours(merged_t_slots)
merged_t_slots
quit
members
compute_total_hours(merged_t_slots)
merged_t_slots
merge_t_slots
q
merged_t_slots
q
q√π
merged_t_slots.second
merged_t_slots
q
merged_t_slots.second
merged_t_slots.first
merged_t_slots
merged_slots
c
next
q
dataI.class
dataI
dataF
dataR
q
merged_t_slots
q
duration
hF
hI
dataF
dataI
group
t_slots
