c
$(document)
<script> 
$
quit
@event.position
@position
@event
Event.last
quit
position_params.nil?
position_params.empty?
position_params
quit
@position.longitude
@position.latitude
@position
@event
event
quit
c
quit
position_params
params[:position]
params[:event]
event_params
quit
event_params
quit
event_params
quit
event_params[:position]
event_params[:position
event_params
quit
event_params
quit
event_params
quit
event_params
quit
event[:members].map{|t| {email: t.strip}}
event[:members].map{|t| {email: t.string}}
event[:members].class
event[:members]
quit
event_params[:members].class
event_params[:members]
event_params
quit
params[:event][:members]
params[:event].member
params[:event].members
params[:event]
[:event]
event_params
quit
event_params
quit
event_params
quit
event_params
quit
event_params
quit
event_params
quit
event_params
quit
event_params
quit
event_params
c
email
:email
part
members
:members
c
part.email
:members[]
:members
p
members
part
quit
quit 
compute_total_hours(merged_t_slots)
merged_t_slots
quit
members
compute_total_hours(merged_t_slots)
merged_t_slots
merge_t_slots
q
merged_t_slots
q
q√π
merged_t_slots.second
merged_t_slots
q
merged_t_slots.second
merged_t_slots.first
merged_t_slots
merged_slots
c
next
q
dataI.class
dataI
dataF
dataR
q
merged_t_slots
q
duration
hF
hI
dataF
dataI
group
t_slots
t_slot
slot
members
merged_t_slots
q
events.items
events
q
data.to_datetime.day
data.to_datetime.class == DateTime
data.to_datetime.class
data.to_datetime.class == 'DateTime'
data.to_datetime.class 
data.to_datetime.class == 'datetime'
data.to_datetime.class == 'datetiem'
(data+"16.07").to_datetime
(data+"16:07").to_datetime
data.to_datetime.DIOCANE
data.to_datetime.date
data.to_datetime
data.class
h
data
dt
q
merged_t_slots
q
res
c
q
res
c
merged_slots
slots
c
res
c
slots
c
slots[1]
slots
c
member
slots
c
slots
member
c
merged_slots
c
res
res.uniq.length
res.uniq
res.length
res
c
slots[3]
slots[1]
slots[2]
slots
c
slots
c
d
quit
c
slots
c
redo
res[member.id] << [mx_date, datetimeF]
res[2].first.uniq
res[2].uniq
res.first.uniq
res.uniq
res.first.last.last
res.first.last
res.first
res.last
res
res[2].last.delete
res[2].last
res[2].last.pop
res[2].last
res[2].last.pop
res[2].last
res[2].last.pop
res
res.last.pop
res.last = nil
add_time(mx_date, duration) < datetimeF
mx_date = datman
datman
res[member.id] << [test.last[1], datetimeF]
add_time(test.last[nd], duration) < datetimeF
res
test[variable]
variable += 1
datman < test[variable][strt]
test[variable][strt] < datman
test[variable]
variable += 1
datman < test[variable][strt]
test[variable][strt] < datman
datman < test[variable][strt]
test[variable]
variable += 1
datman < test[variable][strt]
test[variable][strt] < datman
test[variable]
variable += 1
datman < test[variable][strt]
test[variable][strt] < datman
test[variable]
variable += 1
datman < test[variable][strt]
test[variable][strt] < datman
test[variable]
variable += 1
datman < test[variable][strt]
test[variable][strt] < datman
test[variable]
variable += 1
datman < test[variable][strt]
test[variable][strt] < datman
test[variable]
variable += 1
datman < test[variable][strt]
test[variable][strt] < datman
test[variable]
test.length
variable += 1
datman < test[variable][strt]
res[member.id].last[1] 
res[member.id].empty? || res[member.id].last[1] < test[variable][strt]
